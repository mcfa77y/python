#!/usr/bin/python
import sys, re, SearchReplace
usage = "doService file.java, filterName.txt, [output.txt]"

oldSuperClass = ["SubObjectBaseDTO","SortOrderDTO","CustomizableDTO","LocalizableDTO", "ItemDTO"]
newSuperClass = ["AbstractSubObjectCustomizable","AbstractSortOrderObject","AbstractAuditableCustomizable","AbstractLocalizable","AbstractChild1BizObject"]
oldNewMap = dict(zip(oldSuperClass,newSuperClass))
outputFileName = "output.txt"
filterFileName = "c:/cygwin/home/jlau/one.txt"
DO_MULTIPLE_REPLACE = True
def main():
	global outputFileName,filterFileName, DO_MULTIPLE_REPLACE
	# enforce usage
	if(len(sys.argv) <3):
		print usage
		sys.exit()
	
	# assign inputs
	if(len(sys.argv) == 4):
		outputFileName = sys.argv[3]
	filterFileName = sys.argv[2]
	javaFileName = sys.argv[1]

	sr = SearchReplace.SearchReplace(javaFileName)
	# step 2 
	# base dto
	# step 3
	sr.printStep(3)
	sr.deleteLines( "Generated by XDoclet", -1,3)
	# step 4
	# base dto
	# step 5
	sr.printStep(5)
	go = sr.regExReplace(r'public class (\w+)DTO',r'@Entity\n@Table(name="\1")\npublic class \1DTO', not DO_MULTIPLE_REPLACE)
	if go:
		sr.doImport("import javax.persistence.Table;")	
		sr.doImport("import javax.persistence.Entity;")
		
	# step 6
	sr.printStep(6)
	sr.regExReplace(r'(public .+ getId\(\))',r'@Id\n\1', not DO_MULTIPLE_REPLACE)
	sr.doImport("import javax.persistence.Id;");
	# step 7
	sr.printStep(7)
	#go = sr.regExReplace(r'(Auditable)',r'\1', not DO_MULTIPLE_REPLACE)
	go = sr.checkImplements('Auditable');
	print "Is auditable: "+str(go)
	
	if go:
		sr.regExReplace(r'(merge\(\))',r'//TODO:DTO is Auditable, delete the lines in the merge method that are showing errors and leave the rest.\n \1', not DO_MULTIPLE_REPLACE)
		print "DTO is Auditable, delete the lines in the merge method that are showing errors and leave the rest. "
	else:
		sr.regExReplace(r'(public int hashCode\(\))',r'//TODO:DTO is not Auditable, remove everything below the hashCode declaration.\n \1', not DO_MULTIPLE_REPLACE)
		sr.regExReplace(r'(protected .+ historyProperties .+)',r'//TODO:Remove History Properties.\n\1',not DO_MULTIPLE_REPLACE)
		print "DTO is not Auditable, remove everything below the hashCode declaration."
		print "\t Remove History Properties"
	# step 8
	
	# step 9
	# see step 7's else
	# step 10
	sr.printStep(10)
	sr.regExReplace(r'(public\s+[^{}();]*\s+(get[A-Za-z0-9_]*|[A-Za-z0-9_]*HasBeenSet)\s*\(\s*\))',r'@Transient\n\1', DO_MULTIPLE_REPLACE)
	sr.printStep(filterFileName)
	sr.removeTransient(filterFileName)
	sr.doImport("import javax.persistence.Transient;");
	# step 11
	# base dto
	# step 12
	sr.printStep(12)
	go = sr.regExReplace("EJBException","ServiceException", DO_MULTIPLE_REPLACE)
	if go:
		sr.doImport("import com.bricsnet.core.util.model.ServiceException;");
		sr.regExReplace("import javax.ejb.ServiceException;","",not DO_MULTIPLE_REPLACE)
	# step 13
	sr.printStep(13)
	sr.regExReplace('addValueToMap', 'resetLocalization',DO_MULTIPLE_REPLACE)
	
	# change StateFulBusinesSObject to Stateful
	sr.printStep("StateFulBusinesSObject to Stateful")
	sr.regExReplace('com.bricsnet.core.util.model.StatefulBusinessObject',"com.bricsnet.core.util.model.type.Stateful",not DO_MULTIPLE_REPLACE)
		
	sr.listToFile( outputFileName)

	# insert deleteSoft if deleteStatus is present
	sr.printStep("insert deleteSoft if deleteStatus is present")
	
# replaces the superclass of a file depending on mapping	
def replaceSuperClass(file):
	finished = not DO_MULTIPLE_REPLACE
	
	for i,line in enumerate(file):
		for old, new in oldNewMap.items():
			p = re.compile("extends (\w+\.)*"+old)
			result = p.subn(new, line)
			if result[1]>0:
				if old=="CustomizableDTO" and checkImplements("RootObject"):
					new = "AbstractRootObject"
				if old=="LocalizableDTO" and checkImplements("Auditable"):
					new = "AbstractBizObjectAuditable"
				if old=="ItemDTO" and checkImplements("Auditable"):
					new = "AbstractChild1Auditable"
				print "super: "+old+"\t"+new+"\n\to:"+line
				line = line.replace(old, new)
				file[i] =line
				print "\tn:"+line+"\n\tr:"+result[0]
				sr.doImport( "import com.bricsnet.core.util.impl.service."+new+";")
				finished = DO_MULTIPLE_REPLACE
				break
		if finished:
			break

	if finished:
		print "Super Class replaced"
	else:
		print "Super Class NOT replaced"
		p = re.compile("public abstract class (\w+)")
		for i,line in enumerate(file):
			result = p.match(line)
			if(result):
				file[i] = result.group(0)+" extends AbstractBizObjectService"
				sr.doImport("import com.bricsnet.core.util.impl.service.AbstractBizObjectService;")
				break
				
	return finished


main()
