
/*
 * Generated by XDoclet - Do not edit!
 */
package com.bricsnet.core.dal.report;
import javax.persistence.Transient;
import com.bricsnet.core.util.impl.type.AbstractLocalizable;

/**
 * Value object for LegacyReportBatchKey.
 *
 * @author Patrice Gagnon
 * @version @version@
 */

public class LegacyReportBatchKeyDTO
   extends com.bricsnet.core.util.dto.AbstractLocalizable
   implements java.io.Serializable 
{

   private java.lang.Integer id;
   private boolean idHasBeenSet = false;
   private java.lang.Integer batchKey;
   private boolean batchKeyHasBeenSet = false;
   private java.util.Date date;
   private boolean dateHasBeenSet = false;
   private java.lang.Integer personId;
   private boolean personIdHasBeenSet = false;
   private java.lang.Integer tableId;
   private boolean tableIdHasBeenSet = false;
   private java.lang.Integer recordId;
   private boolean recordIdHasBeenSet = false;

   private java.lang.Integer pk;

   public LegacyReportBatchKeyDTO()
   {
   }

   public LegacyReportBatchKeyDTO( java.lang.Integer id,java.lang.Integer batchKey,java.util.Date date,java.lang.Integer personId,java.lang.Integer tableId,java.lang.Integer recordId )
   {
	  this.id = id;
	  idHasBeenSet = true;
	  this.batchKey = batchKey;
	  batchKeyHasBeenSet = true;
	  this.date = date;
	  dateHasBeenSet = true;
	  this.personId = personId;
	  personIdHasBeenSet = true;
	  this.tableId = tableId;
	  tableIdHasBeenSet = true;
	  this.recordId = recordId;
	  recordIdHasBeenSet = true;
	  pk = this.getId();
   }

   //TODO Cloneable is better than this !
   public LegacyReportBatchKeyDTO( LegacyReportBatchKeyDTO otherValue )
   {
	  this.id = otherValue.id;
	  idHasBeenSet = true;
	  this.batchKey = otherValue.batchKey;
	  batchKeyHasBeenSet = true;
	  this.date = otherValue.date;
	  dateHasBeenSet = true;
	  this.personId = otherValue.personId;
	  personIdHasBeenSet = true;
	  this.tableId = otherValue.tableId;
	  tableIdHasBeenSet = true;
	  this.recordId = otherValue.recordId;
	  recordIdHasBeenSet = true;

	  pk = this.getId();
   }

   @Transient
public java.lang.Integer getPrimaryKey()
   {
	  return pk;
   }

   public void setPrimaryKey( java.lang.Integer pk )
   {
      // it's also nice to update PK object - just in case
      // somebody would ask for it later...
      this.pk = pk;
	  setId( pk );
   }

   @Transient
public java.lang.Integer getId()
   {
	  return this.id;
   }

   public void setId( java.lang.Integer id )
   {
	this.id = id;
	  idHasBeenSet = true;

	resetLocalization("id"); 

	pk = id;
		resetLocalization("primaryKey"); 
   }

   @Transient
public boolean idHasBeenSet(){
	  return idHasBeenSet;
   }
   @Transient
public java.lang.Integer getBatchKey()
   {
	  return this.batchKey;
   }

   public void setBatchKey( java.lang.Integer batchKey )
   {
	this.batchKey = batchKey;
	  batchKeyHasBeenSet = true;

	resetLocalization("batchKey"); 

   }

   @Transient
public boolean batchKeyHasBeenSet(){
	  return batchKeyHasBeenSet;
   }
   @Transient
public java.util.Date getDate()
   {
	  return this.date;
   }

   public void setDate( java.util.Date date )
   {
	this.date = date;
	  dateHasBeenSet = true;

	resetLocalization("date"); 

   }

   @Transient
public boolean dateHasBeenSet(){
	  return dateHasBeenSet;
   }
   @Transient
public java.lang.Integer getPersonId()
   {
	  return this.personId;
   }

   public void setPersonId( java.lang.Integer personId )
   {
	this.personId = personId;
	  personIdHasBeenSet = true;

	resetLocalization("personId"); 

   }

   @Transient
public boolean personIdHasBeenSet(){
	  return personIdHasBeenSet;
   }
   @Transient
public java.lang.Integer getTableId()
   {
	  return this.tableId;
   }

   public void setTableId( java.lang.Integer tableId )
   {
	this.tableId = tableId;
	  tableIdHasBeenSet = true;

	resetLocalization("tableId"); 

   }

   @Transient
public boolean tableIdHasBeenSet(){
	  return tableIdHasBeenSet;
   }
   @Transient
public java.lang.Integer getRecordId()
   {
	  return this.recordId;
   }

   public void setRecordId( java.lang.Integer recordId )
   {
	this.recordId = recordId;
	  recordIdHasBeenSet = true;

	resetLocalization("recordId"); 

   }

   @Transient
public boolean recordIdHasBeenSet(){
	  return recordIdHasBeenSet;
   }

   public String toString()
   {
	  StringBuffer str = new StringBuffer("{");

	  str.append("id=" + getId() + " " + "batchKey=" + getBatchKey() + " " + "date=" + getDate() + " " + "personId=" + getPersonId() + " " + "tableId=" + getTableId() + " " + "recordId=" + getRecordId());
	  str.append('}');

	  return(str.toString());
   }

   /**
    * A Value Object has an identity if the attributes making its Primary Key have all been set. An object without identity is never equal to any other object.
    *
    * @return true if this instance has an identity.
    */
   protected boolean hasIdentity()
   {
	  return idHasBeenSet;
   }

   public boolean equals(Object other)
   {
      if (this == other)
         return true;
	  if ( ! hasIdentity() ) return false;
	  if (other instanceof LegacyReportBatchKeyDTO)
	  {
		 LegacyReportBatchKeyDTO that = (LegacyReportBatchKeyDTO) other;
		 if ( ! that.hasIdentity() ) return false;
		 boolean lEquals = true;
		 if( this.id == null )
		 {
			lEquals = lEquals && ( that.id == null );
		 }
		 else
		 {
			lEquals = lEquals && this.id.equals( that.id );
		 }

		 lEquals = lEquals && isIdentical(that);

		 return lEquals;
	  }

	 return false;
   }

   public boolean isIdentical(Object other)
   {
	  if (other instanceof LegacyReportBatchKeyDTO)
	  {
		 LegacyReportBatchKeyDTO that = (LegacyReportBatchKeyDTO) other;
		 boolean lEquals = true;
		 if( this.batchKey == null )
		 {
			lEquals = lEquals && ( that.batchKey == null );
		 }
		 else
		 {
			lEquals = lEquals && this.batchKey.equals( that.batchKey );
		 }
		 if( this.date == null )
		 {
			lEquals = lEquals && ( that.date == null );
		 }
		 else
		 {
			lEquals = lEquals && this.date.equals( that.date );
		 }
		 if( this.personId == null )
		 {
			lEquals = lEquals && ( that.personId == null );
		 }
		 else
		 {
			lEquals = lEquals && this.personId.equals( that.personId );
		 }
		 if( this.tableId == null )
		 {
			lEquals = lEquals && ( that.tableId == null );
		 }
		 else
		 {
			lEquals = lEquals && this.tableId.equals( that.tableId );
		 }
		 if( this.recordId == null )
		 {
			lEquals = lEquals && ( that.recordId == null );
		 }
		 else
		 {
			lEquals = lEquals && this.recordId.equals( that.recordId );
		 }

		 return lEquals;
	  }

	 return false;
   }

   public int hashCode(){
	  int result = 17;
      result = 37*result + ((this.id != null) ? this.id.hashCode() : 0);

      result = 37*result + ((this.batchKey != null) ? this.batchKey.hashCode() : 0);

      result = 37*result + ((this.date != null) ? this.date.hashCode() : 0);

      result = 37*result + ((this.personId != null) ? this.personId.hashCode() : 0);

      result = 37*result + ((this.tableId != null) ? this.tableId.hashCode() : 0);

      result = 37*result + ((this.recordId != null) ? this.recordId.hashCode() : 0);

	  return result;
   }

	protected static boolean merged = false;
	protected static java.util.Map<String, String> formatMap =
		new java.util.HashMap<String, String>();
	protected static java.util.Map<String, Integer> maxLengths =
		new java.util.HashMap<String, Integer>();
	protected static java.util.Map<String, Number> maxValues =
		new java.util.HashMap<String, Number>();
	protected static java.util.Map<String, Number> minValues =
		new java.util.HashMap<String, Number>();
	protected static java.util.Set<String> historyProperties =
		new java.util.HashSet<String>();
	static {

	// handle bricsnet.localize
		formatMap.put("id", "#"); // PK, java.lang.Integer
	// handle bricsnet.validate
	// bricsnet.hiddenFromHistory
		historyProperties.add("id");

	// handle bricsnet.localize
		formatMap.put("batchKey", "#"); // java.lang.Integer
	// handle bricsnet.validate
	// bricsnet.hiddenFromHistory
		historyProperties.add("batchKey");

	// handle bricsnet.localize
	// handle bricsnet.validate
	// bricsnet.hiddenFromHistory
		historyProperties.add("date");

	// handle bricsnet.localize
		formatMap.put("personId", "#"); // java.lang.Integer
	// handle bricsnet.validate
	// bricsnet.hiddenFromHistory
		historyProperties.add("personId");

	// handle bricsnet.localize
		formatMap.put("tableId", "#"); // java.lang.Integer
	// handle bricsnet.validate
	// bricsnet.hiddenFromHistory
		historyProperties.add("tableId");

	// handle bricsnet.localize
		formatMap.put("recordId", "#"); // java.lang.Integer
	// handle bricsnet.validate
	// bricsnet.hiddenFromHistory
		historyProperties.add("recordId");

	}

	@Transient
public java.util.Map<String, String> getFormatMap() {
		merge();
		return formatMap;
	}
	@Transient
public java.util.Map<String, Integer> getMaxLengthsMap() {
		merge();
		return maxLengths;
	}
	@Transient
public java.util.Map<String, Number> getMaxValuesMap() {
		merge();
		return maxValues;
	}
	@Transient
public java.util.Map<String, Number> getMinValuesMap() {
		merge();
		return minValues;
	}
	// only Auditable objects really need to implement this, 
	// but it's simpler to just give it to everybody
	@Transient
public java.util.Set<String> getHistoryProperties() {
		merge();
		return historyProperties;
	}
	private synchronized void merge() {
		if(merged) return;
			formatMap.putAll(super.getFormatMap());
			maxLengths.putAll(super.getMaxLengthsMap());
			maxValues.putAll(super.getMaxValuesMap());
			minValues.putAll(super.getMinValuesMap());
			historyProperties.addAll(super.getHistoryProperties());
		merged = true;
	}

}
